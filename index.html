<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>World Clock — Analog & Digital + Time Difference Calculator</title>
<meta name="description" content="World Clock with analog + digital displays, timezone & DST info, add/remove clocks, and a time difference calculator. English only."/> 
<!-- Google site verification -->
<meta name="google-site-verification" content="bCxFD6vbWw6huCIFMNp2npHgON51DW3I04xxhGbIsWs" />
<!-- other meta tags and styles/scripts -->
<style>
  :root{
    --bg:#f6f8fb; --card:#ffffff; --muted:#6b7280; --accent:#0b76d1; --accent-2:#e11d48;
    --shadow: 0 8px 24px rgba(2,6,23,0.06); --radius:12px; --text:#0f1724;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,Segoe UI,Roboto,system-ui,-apple-system,"Helvetica Neue",Arial;}
  .container{max-width:1200px;margin:18px auto;padding:18px;}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
  .brand{font-weight:800;font-size:1.1rem}
  .subtitle{font-size:0.9rem;color:var(--muted)}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin:12px 0}
  select,input,button{padding:8px 10px;border-radius:10px;border:1px solid #d1d5db;background:var(--card);font-size:0.95rem}
  button.primary{background:var(--accent);color:#fff;border:none;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(2,6,23,0.06);cursor:pointer}
  .clocks-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:18px;margin-top:12px}
  .clock-card{background:var(--card);border-radius:var(--radius);box-shadow:var(--shadow);padding:14px;position:relative;display:flex;flex-direction:column;align-items:center}
  .city-name{font-weight:700;font-size:1.05rem;margin-bottom:6px;text-align:center}
  .tz-line{font-size:0.86rem;color:var(--muted);margin-bottom:8px;text-align:center}
  /* canvas analog */
  .analog-canvas{width:200px;height:200px;border-radius:50%;display:block;background:linear-gradient(180deg,#fff,#fbfdff);box-shadow:inset 0 6px 18px rgba(2,6,23,0.03);margin-bottom:10px}
  .digital{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,'Courier New',monospace;font-weight:700;font-size:1.2rem;margin-bottom:6px}
  .date-line{font-size:0.86rem;color:var(--muted);margin-bottom:6px;text-align:center}
  .remove-btn{position:absolute;right:10px;top:10px;background:transparent;border:none;color:var(--accent-2);font-weight:700;cursor:pointer}
  .calculator{background:var(--card);padding:14px;border-radius:12px;box-shadow:var(--shadow);margin-top:20px}
  .calc-row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px}
  .calc-row select,.calc-row input{min-width:180px}
  .calc-btn{background:var(--accent);color:white;border:none;padding:10px 14px;border-radius:8px;cursor:pointer}
  pre#calcResult{background:linear-gradient(90deg, rgba(11,118,209,0.04), rgba(225,29,72,0.02));padding:12px;border-radius:8px;min-height:70px;color:var(--text);white-space:pre-wrap}
  /* night mode */
  body.night{background:#0b1220;color:#e6eef8}
  body.night .clock-card{background:#0f1724;color:#e6eef8;box-shadow:0 8px 24px rgba(2,6,23,0.6)}
  body.night .analog-canvas{background:linear-gradient(180deg,#0b1116,#0f1724);border:1px solid rgba(255,255,255,0.03)}
  body.night .tz-line, body.night .date-line{color:#94a3b8}
  /* small screens */
  @media (max-width:560px){
    .analog-canvas{width:170px;height:170px}
    .calc-row select,.calc-row input{min-width:140px}
  }
</style>
<head>
<body>
  <div class="container">
    <header>
      <div>
        <div class="brand">World Clock</div>
        <div class="subtitle">Analog + Digital — Accurate timezones & DST</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="modeToggle" class="ghost" title="Toggle Day/Night">Night mode</button>
      </div>
    </header>

    <div class="controls" role="region" aria-label="controls">
      <select id="cityAddSelect" aria-label="Select city to add"></select>
      <button id="addCityBtn" class="primary">Add Clock</button>
      <div style="margin-left:auto;color:var(--muted)">Powered by browser Intl API</div>
    </div>

    <section class="clocks-grid" id="clocksGrid" aria-live="polite">
      <!-- default 3 clocks will be injected by JS -->
    </section>

    <section class="calculator" aria-label="Time difference calculator">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3 style="margin:0">Time Difference Calculator</h3>
        <small style="color:var(--muted)">Pick date/time in first city</small>
      </div>

      <div class="calc-row">
        <select id="calcCityA" aria-label="Calculator city A"></select>
        <select id="calcCityB" aria-label="Calculator city B"></select>
      </div>
      <div class="calc-row">
        <input type="date" id="calcDate" aria-label="Calculator date" />
        <input type="time" id="calcTime" aria-label="Calculator time" step="60" />
      </div>
      <div style="display:flex;gap:10px;margin-top:10px">
        <button id="calcBtn" class="calc-btn">Calculate</button>
        <button id="swapBtn" class="calc-btn" style="background:#ef4444">Swap</button>
      </div>

      <pre id="calcResult" aria-live="polite"></pre>
    </section>
  </div>

<script>
/* ---------------------------
   Full single-file working app
   ---------------------------
   - Uses Intl.supportedValuesOf('timeZone') when available to provide a full IANA list
   - Falls back to a comprehensive list if not available
   - Accurate offsets & DST detection using Intl
   - Canvas analog clocks with 1..12 numbers
   - Full time-difference calculator (works for past/future)
   - Default three clocks: New York, London, Tokyo
   --------------------------- */

(function(){
  // DOM refs
  const cityAddSelect = document.getElementById('cityAddSelect');
  const addCityBtn = document.getElementById('addCityBtn');
  const clocksGrid = document.getElementById('clocksGrid');
  const modeToggle = document.getElementById('modeToggle');
  const calcCityA = document.getElementById('calcCityA');
  const calcCityB = document.getElementById('calcCityB');
  const calcDate = document.getElementById('calcDate');
  const calcTime = document.getElementById('calcTime');
  const calcBtn = document.getElementById('calcBtn');
  const swapBtn = document.getElementById('swapBtn');
  const calcResult = document.getElementById('calcResult');

  // Attempt to use full Intl timezone list if available
  let TIMEZONES = [];
  if (typeof Intl === 'object' && typeof Intl.supportedValuesOf === 'function') {
    try {
      TIMEZONES = Intl.supportedValuesOf('timeZone');
    } catch (e) {
      TIMEZONES = [];
    }
  }

  // Fallback comprehensive timezone list (good coverage)
  if (!TIMEZONES || !TIMEZONES.length) {
    TIMEZONES = [
      "Pacific/Midway","Pacific/Honolulu","America/Anchorage","America/Los_Angeles","America/Tijuana",
      "America/Denver","America/Phoenix","America/Chihuahua","America/Chicago","America/Regina","America/Mexico_City",
      "America/Monterrey","America/Guatemala","America/New_York","America/Indiana/Indianapolis","America/Bogota",
      "America/Lima","America/Halifax","America/Caracas","America/Santiago","America/St_Johns","America/Sao_Paulo",
      "America/Argentina/Buenos_Aires","America/Godthab","Atlantic/Azores","Atlantic/Cape_Verde","Europe/London",
      "Europe/Lisbon","Europe/Dublin","Europe/Amsterdam","Europe/Paris","Europe/Berlin","Europe/Prague","Europe/Rome",
      "Europe/Stockholm","Europe/Warsaw","Europe/Athens","Europe/Moscow","Asia/Jerusalem","Africa/Cairo",
      "Africa/Johannesburg","Asia/Beirut","Asia/Dubai","Asia/Tehran","Asia/Karachi","Asia/Kolkata","Asia/Dhaka",
      "Asia/Bangkok","Asia/Ho_Chi_Minh","Asia/Singapore","Asia/Shanghai","Asia/Taipei","Asia/Seoul","Asia/Tokyo",
      "Australia/Perth","Australia/Adelaide","Australia/Sydney","Pacific/Auckland","Pacific/Fiji","Pacific/Chatham",
      "Europe/Zurich","Europe/Brussels","Europe/Vienna","Europe/Budapest","Europe/Copenhagen","America/Toronto",
      "America/Vancouver","America/Winnipeg","America/Puerto_Rico","America/Montevideo","Africa/Nairobi","Africa/Accra",
      "Africa/Algiers","Asia/Yangon","Asia/Yekaterinburg","Asia/Kathmandu","Pacific/Wallis","Pacific/Futuna",
      "Indian/Maldives","Indian/Mauritius","Asia/Amman","Europe/Bucharest","Europe/Helsinki","Europe/Riga",
      "Europe/Vilnius","Europe/Tallinn","Europe/Belgrade","Europe/Sofia","Europe/Zagreb","Europe/Skopje",
      "Europe/Ljubljana","Europe/Bratislava","Europe/Istanbul","Asia/Baghdad","Asia/Kuwait","Asia/Riyadh",
      "Asia/Muscat","Africa/Casablanca","Atlantic/Canary","America/Aruba","America/Curacao","America/La_Paz",
      "America/Guayaquil","America/Asuncion","America/Belize","America/Costa_Rica","America/El_Salvador",
      "America/Havana","America/Jamaica","America/Panama","America/Port_of_Spain","America/Caracas",
      "Pacific/Guadalcanal","Pacific/Port_Moresby","Pacific/Noumea","Asia/Magadan","Asia/Kamchatka"
      // (If you want absolutely every single IANA zone, let me know and I can extend further)
    ];
  }

  // Helper: Display label for timezone (human friendly)
  function tzLabel(tz){
    // Build a friendly label: "City — Continent/Region"
    const parts = tz.split('/');
    const last = parts[parts.length-1].replace(/_/g,' ').replace(/-/g,' ');
    return `${last} — ${tz}`;
  }

  // Utilities: offset minutes, DST detection (uses Intl)
  function getOffsetMinutesFor(date, timeZone) {
    // Return offset minutes where positive = ahead of UTC
    const dtf = new Intl.DateTimeFormat('en-US', {
      timeZone,
      year: 'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit',
      hour12: false
    });
    const parts = dtf.formatToParts(date);
    const map = {};
    for (const p of parts) if (p.type !== 'literal') map[p.type] = p.value;
    const y = parseInt(map.year,10), mo = parseInt(map.month,10)-1, d = parseInt(map.day,10);
    const h = parseInt(map.hour,10), m = parseInt(map.minute,10), s = parseInt(map.second,10);
    const utcMillisFromParts = Date.UTC(y, mo, d, h, m, s);
    return Math.round((utcMillisFromParts - date.getTime()) / 60000);
  }

  function isDSTFor(date, tz){
    const jan = new Date(date.getFullYear(),0,1);
    const jul = new Date(date.getFullYear(),6,1);
    const offJan = getOffsetMinutesFor(jan,tz);
    const offJul = getOffsetMinutesFor(jul,tz);
    const std = Math.max(offJan, offJul);
    const current = getOffsetMinutesFor(date,tz);
    return current < std;
  }

  function formatOffset(mins){
    const sign = mins >= 0 ? '+' : '-';
    const abs = Math.abs(mins);
    const h = Math.floor(abs/60).toString().padStart(2,'0');
    const m = (abs%60).toString().padStart(2,'0');
    return `UTC${sign}${h}:${m}`;
  }

  // get hour/min/sec parts for timezone at given Date
  function getPartsForTime(date, tz){
    const parts = new Intl.DateTimeFormat('en-GB', { timeZone: tz, hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false }).formatToParts(date);
    let hour=0, minute=0, second=0;
    for(const p of parts){
      if(p.type==='hour') hour = Number(p.value);
      if(p.type==='minute') minute = Number(p.value);
      if(p.type==='second') second = Number(p.value);
    }
    return {hour, minute, second};
  }

  // convert wall-clock local time in tz to UTC ms
  function localWallTimeToUTCms(year, month, day, hour, minute, second, tz){
    const asIfUTC = Date.UTC(year, month-1, day, hour, minute, second);
    const asIfDate = new Date(asIfUTC);
    const offsetMin = getOffsetMinutesFor(asIfDate, tz);
    return asIfUTC - offsetMin * 60000;
  }

  // app state
  const defaultTZs = ['America/New_York','Europe/London','Asia/Tokyo'];
  let activeTZs = defaultTZs.slice();

  // populate add select and calculator selects
  function populateSelects(){
    // add select: exclude active tzs
    cityAddSelect.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value=''; placeholder.disabled=true; placeholder.selected=true;
    placeholder.textContent = 'Select a city...';
    cityAddSelect.appendChild(placeholder);

    for(const tz of TIMEZONES){
      if(activeTZs.includes(tz)) continue;
      const opt = document.createElement('option'); opt.value = tz; opt.textContent = tzLabel(tz);
      cityAddSelect.appendChild(opt);
    }
    // calculator selects (full list)
    calcCityA.innerHTML = ''; calcCityB.innerHTML = '';
    for(const tz of TIMEZONES){
      const a = document.createElement('option'); a.value = tz; a.textContent = tzLabel(tz);
      const b = document.createElement('option'); b.value = tz; b.textContent = tzLabel(tz);
      calcCityA.appendChild(a); calcCityB.appendChild(b);
    }
    // sensible defaults
    calcCityA.value = activeTZs[0] || TIMEZONES[0];
    calcCityB.value = 'Europe/London';
  }

  // Canvas drawing helpers
  function setupCanvas(canvas){
    // high DPI handling
    const size = Math.min(canvas.clientWidth, canvas.clientHeight);
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(size * dpr);
    canvas.height = Math.round(size * dpr);
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0); // scale
    return ctx;
  }

  function drawFace(ctx, radius){
    // outer circle
    ctx.beginPath();
    ctx.arc(0,0,radius,0,2*Math.PI);
    // fill background slightly shaded
    const grad = ctx.createLinearGradient(0,-radius,0,radius);
    grad.addColorStop(0, '#ffffff'); grad.addColorStop(1, '#f2f7ff');
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.lineWidth = 4;
    ctx.strokeStyle = 'rgba(11,118,209,0.12)';
    ctx.stroke();

    // center dot will be drawn later by hands
  }

  function drawNumbers(ctx, radius){
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#0b76d1';
    ctx.font = `${Math.round(radius*0.13)}px sans-serif`;
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'center';
    const innerR = radius * 0.78;
    for(let i=1;i<=12;i++){
      const ang = (i/12)*2*Math.PI - Math.PI/2;
      const x = Math.cos(ang) * innerR;
      const y = Math.sin(ang) * innerR;
      ctx.fillText(String(i), x, y);
    }
  }

  function drawHands(ctx, radius, hourDeg, minuteDeg, secondDeg){
    // hour
    ctx.save();
    ctx.rotate(hourDeg * Math.PI/180);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text') || '#0f1724';
    roundRectFill(ctx, -4, -radius*0.5, 8, radius*0.5, 4);
    ctx.restore();

    // minute
    ctx.save();
    ctx.rotate(minuteDeg * Math.PI/180);
    roundRectFill(ctx, -3, -radius*0.72, 6, radius*0.72, 3);
    ctx.restore();

    // second
    ctx.save();
    ctx.rotate(secondDeg * Math.PI/180);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-2') || '#e11d48';
    ctx.fillRect(-1, -radius*0.86, 2, radius*0.86);
    ctx.restore();

    // center dot
    ctx.beginPath();
    ctx.arc(0,0,6,0,2*Math.PI);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#0b76d1';
    ctx.fill();
  }

  function roundRectFill(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.fill();
  }

  // create a clock card for tz
  function createClockCard(tz){
    const wrapper = document.createElement('article');
    wrapper.className = 'clock-card';
    wrapper.setAttribute('data-tz', tz);

    const remove = document.createElement('button'); remove.className='remove-btn'; remove.textContent='✕'; remove.title='Remove clock';
    remove.addEventListener('click', ()=>{
      activeTZs = activeTZs.filter(t => t !== tz);
      renderAll();
    });
    wrapper.appendChild(remove);

    const name = document.createElement('div'); name.className='city-name'; name.textContent = tz.split('/').slice(-1)[0].replace(/_/g,' ');
    wrapper.appendChild(name);

    const tzLine = document.createElement('div'); tzLine.className='tz-line'; tzLine.textContent = tz;
    wrapper.appendChild(tzLine);

    const canvas = document.createElement('canvas'); canvas.className='analog-canvas';
    canvas.width = 200; canvas.height = 200;
    wrapper.appendChild(canvas);

    const digital = document.createElement('div'); digital.className='digital'; digital.textContent='--:--:--';
    wrapper.appendChild(digital);

    const dateLine = document.createElement('div'); dateLine.className='date-line'; dateLine.textContent='';
    wrapper.appendChild(dateLine);

    return wrapper;
  }

  // render grid of active clocks
  function renderAll(){
    clocksGrid.innerHTML = '';
    for(const tz of activeTZs){
      const card = createClockCard(tz);
      clocksGrid.appendChild(card);
    }
    populateSelects();
    // small delay to ensure CSS sizes applied before drawing numbers
    setTimeout(()=> updateTimes(), 30);
  }

  // update every clock
  function updateTimes(){
    const now = new Date();
    const cards = Array.from(clocksGrid.querySelectorAll('.clock-card'));
    for(const card of cards){
      const tz = card.getAttribute('data-tz');
      const canvas = card.querySelector('canvas');
      const ctx = setupCanvas(canvas);
      ctx.clearRect(-canvas.width, -canvas.height, canvas.width*2, canvas.height*2);
      // center coords at 0,0
      ctx.translate(canvas.width/(2*(window.devicePixelRatio||1)), canvas.height/(2*(window.devicePixelRatio||1)));

      // draw face & numbers
      const radius = Math.min(canvas.clientWidth, canvas.clientHeight)/2 - 6;
      drawFace(ctx, radius);
      drawNumbers(ctx, radius);

      // get parts using Intl for accuracy
      const p = getPartsForTime(now, tz);
      const hour = p.hour, minute = p.minute, second = p.second;
      const hourAngle = ((hour % 12) + minute/60) * 30;
      const minuteAngle = (minute + second/60) * 6;
      const secondAngle = second * 6;

      drawHands(ctx, radius, hourAngle, minuteAngle, secondAngle);

      // digital text
      const digital = card.querySelector('.digital');
      digital.textContent = new Intl.DateTimeFormat('en-GB', { timeZone: tz, hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false }).format(now);

      // tz info line (offset and DST)
      const dateLine = card.querySelector('.date-line');
      const offsetMin = getOffsetMinutesFor(now, tz);
      const offsetStr = formatOffset(offsetMin);
      const dst = isDSTFor(now, tz) ? 'Yes' : 'No';
      dateLine.textContent = `${offsetStr} · DST: ${dst}`;

      // restore transform by resetting canvas (simple approach)
      ctx.setTransform(1,0,0,1,0,0);
    }
  }

  // add city handler
  addCityBtn.addEventListener('click', ()=>{
    const tz = cityAddSelect.value;
    if(!tz) return;
    if(activeTZs.includes(tz)){
      alert('City already displayed');
      return;
    }
    activeTZs.push(tz);
    renderAll();
  });

  // day/night toggle
  modeToggle.addEventListener('click', ()=>{
    document.body.classList.toggle('night');
    const isNight = document.body.classList.contains('night');
    modeToggle.textContent = isNight ? 'Day mode' : 'Night mode';
  });

  // calculator: convert CityA local wall time to CityB local time
  calcBtn.addEventListener('click', ()=>{
    const a = calcCityA.value;
    const b = calcCityB.value;
    if(!a || !b){ calcResult.textContent = 'Select both cities.'; return; }
    const dateStr = calcDate.value;
    const timeStr = calcTime.value;
    if(!dateStr || !timeStr){ calcResult.textContent = 'Pick date and time in first city.'; return; }
    // parse
    const [Y, M, D] = dateStr.split('-').map(s=>parseInt(s,10));
    const [hh, mm] = timeStr.split(':').map(s=>parseInt(s,10));
    const ss = 0;
    // convert to UTC ms that corresponds to that wall time in city A
    const utcMs = localWallTimeToUTCms(Y, M, D, hh, mm, ss, a);
    const utcDate = new Date(utcMs);
    // city B local time at that UTC instant
    const partsB = new Intl.DateTimeFormat('en-GB', { timeZone: b, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false}).formatToParts(utcDate);
    const mapB = {}; for(const p of partsB) if(p.type !== 'literal') mapB[p.type] = p.value;
    const cityBlocalStr = `${mapB.year}-${mapB.month}-${mapB.day} ${mapB.hour}:${mapB.minute}:${mapB.second}`;

    // offsets and DST
    const offsetAmin = getOffsetMinutesFor(utcDate, a);
    const offsetBmin = getOffsetMinutesFor(utcDate, b);
    const diffMin = offsetBmin - offsetAmin;
    const hdiff = diffMin / 60;
    const dstA = isDSTFor(utcDate,a) ? 'Yes' : 'No';
    const dstB = isDSTFor(utcDate,b) ? 'Yes' : 'No';

    calcResult.textContent =
`${a} local → ${new Intl.DateTimeFormat('en-GB',{ timeZone: a, year:'numeric', month:'short', day:'numeric', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false }).format(new Date(utcMs + offsetAmin*60000))}
${b} local → ${cityBlocalStr}

Time difference (B - A): ${hdiff >= 0 ? '+' : ''}${hdiff} hours
${a} DST: ${dstA}
${b} DST: ${dstB}
(Reference UTC: ${new Date(utcMs).toUTCString()})`;
  });

  swapBtn.addEventListener('click', ()=>{
    const tmp = calcCityA.value; calcCityA.value = calcCityB.value; calcCityB.value = tmp;
  });

  // defaults for calc date/time
  function setCalcDefaults(){
    const now = new Date();
    calcDate.value = now.toISOString().slice(0,10);
    calcTime.value = now.toTimeString().slice(0,5);
  }

  // initialization
  function init(){
    populateSelects();
    renderAll();
    setCalcDefaults();
    updateTimes();
    setInterval(updateTimes, 1000);
  }

  // expose in window for testing/debug (optional)
  window.__worldClock = {
    TIMEZONES,
    activeTZs,
    renderAll,
    updateTimes
  };

  // start
  init();

})();
</script>
</body>
</html>
